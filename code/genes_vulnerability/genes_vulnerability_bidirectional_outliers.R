#################
### Load data ###
#################

rm(list=setdiff(ls(),c('params','grp','injection.site')))
print(grp)
basedir <- params$basedir
setwd(basedir)
savedir <- paste(params$opdir,'genes_vulnerability/',paste0(injection.site,collapse='-'),'/',sep='')
dir.create(savedir,recursive=T)

source('code/misc/fitfxns.R')
source('code/misc/optimfxns.R')
source('code/misc/miscfxns.R')
source('code/misc/plottingfxns.R')
source('code/misc/normfuns.R')

load(paste(params$opdir,'processed/pathdata.RData',sep=''))  # load path data and ROI names

r.method <- 'pearson' # set method for correlation

##########################
### load vulnerability ###
##########################

vuln.dir <- paste(params$opdir,'diffmodel/bidirectional_onelm/',paste0(injection.site,collapse='-'),'/',sep='')
# compute intrinsic vulnerability as an average over time and hemispheres
tp.excl <- '1 MPI' # exclude 1 MPI - see diffmodel/vuln_hemi_time.R
df.vuln <- read.csv(paste0(vuln.dir,grp,'vulnerability_bidirectional_hemiaverage_exclude',tp.excl,'.csv'),row.names = 1)

#################################
### load gene expression data ###
#################################

df.gene <- read.csv('data/aba/expression/AllGeneExpression_Fulcher2019.csv',row.names = 1)

# convert hemisphere averaged gene expression to CNDR space
rownames(df.gene) <- paste0('i',rownames(df.gene)) # add i so mapping function works
df.gene.CNDR <- map.ABA.to.CNDR(df.gene,path.names,ABA.to.CNDR.key)
df.gene.CNDR <- df.gene.CNDR[paste0('i',rownames(df.vuln)),] # remove contra regions which are all na and order like vulnerability
rownames(df.gene.CNDR) <- substr(rownames(df.gene.CNDR),2,nchar(rownames(df.gene.CNDR))) # remove i from names


# r.mat <- cor(df.gene.CNDR,use='pairwise.complete.obs',method = r.method)
# hc <- hclust(as.dist(1-r.mat))
# image(r.mat[hc$order,hc$order])

#df.gene.CNDR <- df.gene.CNDR[,-which(colSums(is.na(df.gene.CNDR)) > 0.1*nrow(df.gene.CNDR))]
gene.names <- colnames(df.gene.CNDR)
names(gene.names) <- gene.names
region.names.gene <- rownames(df.gene.CNDR)

# find outliers now; remove later. start by marking injection sites (often outliers)
injection.site.CNDR <- unname(params$injection.site.CNDR[injection.site]) # convert injection site from ABA to CNDR
injection.site.CNDR <- substr(injection.site.CNDR,2,nchar(injection.site.CNDR)) # exclude injection site

# make regressor for injection sites
inj.site.indicator <- name(as.integer(region.names.gene %in% injection.site.CNDR),region.names.gene)

#injection.site.CNDR <- c() # don't exclude injection site
outlier.fun <- function(x){
  # return outlier names
  return(names(boxplot.stats(x)$out))
}
vuln.named <- name(df.vuln$v,rownames(df.vuln))
vuln.outliers <- outlier.fun(vuln.named) # find outliers in vulnerability

gene.outliers <- lapply(gene.names, function(g) c(vuln.outliers,names(boxplot.stats(df.gene.CNDR[,g])$out)))
region.names.gene <- rownames(df.gene.CNDR)
#gene.outlier.mask <- lapply(gene.names, function(g) !region.names.gene %in% gene.outliers[[g]] & !region.names.gene %in% injection.site.CNDR) # don't exclude injection sites- model them
gene.outlier.mask <- lapply(gene.names, function(g) !region.names.gene %in% gene.outliers[[g]])

if(r.method=='spearman'){ # if using spearman don't exclude outliers
  gene.outlier.mask <- lapply(gene.names, function(g) rep(TRUE,length(region.names.gene)))
}
##############################
### PCA of gene expression ###
##############################

X <- df.gene.CNDR[setdiff(rownames(df.gene.CNDR),'ZI'),]
X <- X[,colSums(is.na(X))==0]
for(j in 1:ncol(X)){X[,j] <- X[,j] - mean(X[,j])} # center every variable in X
pca <- prcomp(X)
pca$scores <- X %*% pca$rotation[,drop=F]
r.pc.vuln <- lapply(colnames(pca$scores), function(g) cor.test(df.vuln[setdiff(rownames(df.gene.CNDR),'ZI'),'v'],pca$scores[,g],method=r.method))
r.pc.vuln.r <- sapply(r.pc.vuln, function(X) unname(X$estimate))
r.pc.vuln.p <- p.adjust(sapply(r.pc.vuln, function(X) unname(X$p.value)))

####################################################################
### simple correlation between gene expression and vulnerability ###
####################################################################

r.gene.vuln <- lapply(gene.names, function(g) cor.test(df.vuln$v[gene.outlier.mask[[g]]],df.gene.CNDR[gene.outlier.mask[[g]],g],
                                                       use = 'pairwise.complete.obs',
                                                       method =r.method))
r.gene.vuln <- lapply(gene.names, function(g) cor.test(rank_INT(df.vuln$v),rank_INT(df.gene.CNDR[,g]),
                                                       use = 'pairwise.complete.obs',
                                                       method =r.method))
r.gene.vuln.r <- sapply(r.gene.vuln, function(X) unname(X$estimate))
r.gene.vuln.p <- sapply(r.gene.vuln, function(X) unname(X$p.value))

# instead of correlation use regression with injection site indicator as a regressor
# df.gene.vuln <- lapply(gene.names, function(g) data.frame(y=df.vuln$v[gene.outlier.mask[[g]]],g=df.gene.CNDR[gene.outlier.mask[[g]],g],i=inj.site.indicator[gene.outlier.mask[[g]]]))
# m.gene.vuln <- lapply(df.gene.vuln, function(df) lm.beta(lm(y~g+i,data=df)))
# 
# r.gene.vuln.r <- sapply(m.gene.vuln, function(X) summary(X)$r.squared)
# r.gene.vuln.p <- sapply(m.gene.vuln, function(X) summary(X)$coefficients['g','Pr(>|t|)'])
# fv.gene.vuln <- lapply(m.gene.vuln, function(X) data.frame(v=X$model$y,f=X$fitted.values))

r.gene.vuln.p.bonf <- p.adjust(r.gene.vuln.p,method='bonferroni')
r.gene.vuln.p.fdr <- p.adjust(r.gene.vuln.p,method = 'fdr')

ord <- order(abs(r.gene.vuln.r),decreasing = T)

n <- 100
df.res <- data.frame(r=r.gene.vuln.r[ord][1:n],p_bonf=r.gene.vuln.p.bonf[ord][1:n],p_fdr=r.gene.vuln.p.fdr[ord][1:n],p_un=r.gene.vuln.p[ord][1:n])
write.csv(x=df.res,file = paste0(savedir,grp,'Top',n,'GenesVulnerability',r.method,'.csv'))

genes.vuln.related <- names(r.gene.vuln.r)[r.gene.vuln.p.fdr<0.05]
if(length(genes.vuln.related)>0){
  gene.r.mat <- cor(df.gene.CNDR[,genes.vuln.related],use = 'pairwise.complete.obs',method = 'pearson')
  hc <- hclust(as.dist(1-gene.r.mat)) # simple hierarchical clustering to group genes by similarity
  p <- imagesc(gene.r.mat[hc$order,hc$order],cmap = 'redblue',clim = c(-1,1),caxis_name = 'r') + coord_equal()+ 
    theme(axis.text.x=element_text(angle=90,vjust=0.5,hjust=1)) +
    ggtitle('Spatial Similarity of Expression Patterns\nFor Vulnerability-Related Genes') + theme(plot.title = element_text(hjust=0.5)) +
    nice_cbar()
  ggsave(p,filename = paste0(savedir,grp,'SimilarityOfVulnerabilityRelatedGenes',r.method,'.pdf'),
         units = 'cm',height = 6,width = 6,useDingbats=FALSE)
}


# regression model
p.list <- lapply(genes.vuln.related, function(g) p.xy.flex(x=fv.gene.vuln[[g]]$f,y=fv.gene.vuln[[g]]$v,
                                                           xlab = g,ylab='Vulnerability',ptxt = 'p[FDR] == ',parse = T,rtxt = 'r == ',
                                                           ttl = '',alpha = 0.8,col = wes_palettes$BottleRocket1[6],p=df.res[g,'p_fdr'],pos = 'top.right',r.method = r.method))

# INT
p.list <- lapply(genes.vuln.related, function(g) p.xy.flex(x=rank_INT(df.gene.CNDR[,g]),y=rank_INT(df.vuln$v),
                                                           xlab = g,ylab='Vulnerability',ptxt = 'p[FDR] == ',parse = T,rtxt = 'r == ',
                                                           ttl = '',alpha = 0.8,col = wes_palettes$BottleRocket1[6],p=df.res[g,'p_fdr'],pos = 'top.right',r.method = r.method))

# p.list <- lapply(genes.vuln.related, function(g) p.xy.flex(x=df.gene.CNDR[gene.outlier.mask[[g]],g],y=df.vuln$v[gene.outlier.mask[[g]]],
#                                                            xlab = g,ylab='Vulnerability',ptxt = 'p[FDR] == ',parse = T,rtxt = 'r == ',
#                                                   ttl = '',alpha = 0.8,col = wes_palettes$BottleRocket1[6],p=df.res[g,'p_fdr'],pos = 'top.right',r.method = r.method))
p.all <- plot_grid(plotlist = p.list,ncol=7,nrow=3)
ggsave(p.all,filename = paste(savedir,grp,'VulnerabilityRelatedGenesFDR',r.method,'.pdf',sep=''),
       units = 'cm',height = 9,width = 18,useDingbats=FALSE)

### only analyze genes that are more highly expressed in NFT+ neurons ###
# https://www.biorxiv.org/content/10.1101/2020.05.11.088591v1.full.pdf
# gene.list <- read.csv('data/TauVulnGOI.csv',header=F,stringsAsFactors = F)
# gene.list <- setNames(as.list(gene.list$V1),gene.list$V1)
# gene.list <- gene.list[unlist(gene.list) %in% colnames(df.gene.CNDR)]
# r.gene.vuln <- lapply(gene.list, function(g) cor.test(df.vuln$v,df.gene.CNDR[,g],use = 'pairwise.complete.obs',method =r.method))
# r.gene.vuln.r <- sapply(r.gene.vuln, function(X) unname(X$estimate))
# r.gene.vuln.p <- sapply(r.gene.vuln, function(X) unname(X$p.value))
# r.gene.vuln.p.bonf <- p.adjust(r.gene.vuln.p)
# r.gene.vuln.p.fdr <- p.adjust(r.gene.vuln.p,method = 'fdr')
# 
# ord <- order(abs(r.gene.vuln.r),decreasing = T)
# 
# df.res <- data.frame(r=r.gene.vuln.r[ord],p_bonf=r.gene.vuln.p.bonf[ord],p_fdr=r.gene.vuln.p.fdr[ord])
# write.csv(x=df.res,file = paste0(savedir,grp,'OteroGarciaGenes.csv'))


### simple correlation between gene expression and NTG-G20 pathology

tps <- params$tps
log.path <- list()
for(grp in params$grps){
  Mice <- lapply(tps, function(tp) path.data[path.data$Condition == grp & path.data$Month == tp,path.names])
  log.path[[grp]] <- lapply(Mice, function(X) log(colMeans(X,na.rm=T),base=10))
}

path.diff <- as.data.frame(do.call(cbind,lapply(1:length(tps), function(t.) log.path$NTG[[t.]] - log.path$G20[[t.]])))
colnames(path.diff) <- paste(tps,'MPI')
path.diff[path.diff == Inf | path.diff == -Inf] <- NA
path.diff.hemi <- hemi.average(path.diff[,setdiff(colnames(path.diff),tp.excl)])
r.gene.pathdiff <- lapply(gene.names, function(g) cor.test(path.diff.hemi$v,df.gene.CNDR[,g],use = 'pairwise.complete.obs',method =r.method))
r.gene.pathdiff.r <- sapply(r.gene.pathdiff, function(X) unname(X$estimate))
r.gene.pathdiff.p <- p.adjust(sapply(r.gene.pathdiff, function(X) unname(X$p.value)))
r.gene.pathdiff.p <- sapply(r.gene.pathdiff, function(X) unname(X$p.value))
r.gene.pathdiff.p.bonf <- p.adjust(r.gene.pathdiff.p)
r.gene.pathdiff.p.fdr <- p.adjust(r.gene.pathdiff.p,method = 'fdr')

ord <- order(abs(r.gene.pathdiff.r),decreasing = T)
n <- 100
df.res <- data.frame(r=r.gene.pathdiff.r[ord][1:n],p_bonf=r.gene.pathdiff.p.bonf[ord][1:n],p_fdr=r.gene.pathdiff.p.fdr[ord][1:n],p_un=r.gene.pathdiff.p[ord][1:n])
write.csv(x=df.res,file = paste0(savedir,'Top',n,'GenesNTGMinusG20Path',r.method,'.csv'))
plot(df.gene.CNDR[,"Mdfi"],path.diff.hemi$v)

genes.pathdiff.related <- names(r.gene.pathdiff.r)[r.gene.pathdiff.p.fdr<0.05]
if(length(genes.pathdiff.related)>0){
  gene.r.mat <- cor(df.gene.CNDR[,genes.pathdiff.related],use = 'pairwise.complete.obs',method = r.method)
  hc <- hclust(as.dist(1-gene.r.mat)) # simple hierarchical clustering to group genes by similarity
  p <- imagesc(gene.r.mat[hc$order,hc$order],cmap = 'redblue',clim = c(-1,1),caxis_name = 'r') + coord_equal()+ 
    theme(axis.text.x=element_text(angle=90,vjust=0.5,hjust=1)) +
    ggtitle('Spatial Similarity of Expression Patterns\nFor G20-Related Genes') + theme(plot.title = element_text(hjust=0.5)) +
    nice_cbar() + theme(axis.text = element_blank(),axis.ticks = element_blank())
  ggsave(p,filename = paste0(savedir,'SimilarityOfNTGMinusG20PathRelatedGenes',r.method,'.png'),
         units = 'cm',height = 6,width = 6,dpi=300)
}