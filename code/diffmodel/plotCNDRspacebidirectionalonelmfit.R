#################
### Load data ###
#################

rm(list=setdiff(ls(),c('params','grp','injection.site','goi')))
print(grp)
basedir <- params$basedir
setwd(basedir)
savedir <- paste(params$opdir,'diffmodel/bidirectional_onelm/',paste0(injection.site,collapse='-'),'/',sep='')
dir.create(savedir,recursive=T)

source('code/misc/fitfxns.R')
source('code/misc/miscfxns.R')
source('code/misc/plottingfxns.R')
load(paste(params$opdir,'processed/pathdata.RData',sep=''))  # load path data and ROI names
load(paste(savedir,grp,'CNDRSpaceBidirectionalOptimOneLM_data.RData',sep=''))
tps <- params$tps
col <- getGroupColors(params$grps)[grp] # get color for plots

# exclude regions with 0 pathology at each time point for purposes of computing fit
for(t. in 1:length(df)){colnames(df[[t.]]) <- c('y','pred.retro','pred.antero')} # rename regression predictors for consistency and interpretability. This should actually be done in optimfxns.R: lm.mask.ant.ret.all
lapply(1:length(tps), function(t) paste0(t,' MPI: ',sum(df[[t]]$y != -Inf & !is.na(df[[t]]$pred.retro)),'/',nrow(df[[t]]),' regions left'))

##########################################################
### add together anterograde and retrograde prediction ###
##########################################################

# m is linear regression model objects that combine anterograde and retrograde predictions at each time point
# generated by code/diffmodel/optim_bidirectionalspread_onelm_CNDRspace.R
df.rnames <- lapply(df,rownames)
vulnerability <- lapply(df.rnames, function(rn) residuals(m)[rn])
pred <- lapply(df.rnames, function(rn) m$fitted.values[rn])
path.t <- lapply(df.rnames, function(rn) m$model[rn,'y',drop=FALSE])

p <- lapply(1:length(tps), function(t) 
  p.xy(x=pred[[t]],y=path.t[[t]],ylab='Actual',xlab='Predicted',
       ttl=paste0(grp,': ',tps[t],' MPI'),col=col,alpha=0.7))
p <- plot_grid(plotlist=p,align='hv',nrow=1)
ggsave(p,filename = paste(savedir,grp,'CNDRSpaceFit_bidirectionaladditivemodel.pdf',sep=''),
       units = 'cm',height = 3.75,width = 3.75*length(tps),useDingbats=FALSE)

# exclude injection sites - concern that injection sites are outliers throwing off measurement of fit
injection.site.CNDR <- unname(params$injection.site.CNDR[injection.site]) # convert injection site from ABA to CNDR
excl.inj <- lapply(1:length(tps), function(t.) paste0(injection.site.CNDR,'_',t.))

p <- lapply(1:length(tps), function(t.) 
  p.xy(x=pred[[t.]][!df.rnames[[t.]] %in% excl.inj[[t.]]],y=path.t[[t.]][!df.rnames[[t.]] %in% excl.inj[[t.]],],ylab='Actual',xlab='Predicted',
       ttl=paste0(grp,': ',tps[t.],' MPI'),col=col,alpha=0.7))
p <- plot_grid(plotlist=p,align='hv',nrow=1)

ggsave(p,filename = paste(savedir,grp,'CNDRSpaceFit_bidirectionaladditivemodel_ExcludeInjectionSites.pdf',sep=''),
       units = 'cm',height = 3.75,width = 3.75*length(tps),useDingbats=FALSE)

# plot fit and label each region
geom_label_repel(aes(label = Region),
                 point.padding = 0.5,
                 segment.color = 'grey50')
p <- list()
for(t. in 1:length(tps)){
  t.path.names <- substr(names(pred[[t.]]),1,nchar(names(pred[[t.]]))-2)
  df.tmp <- data.frame(x=pred[[t.]],y=path.t[[t.]],lab=t.path.names)
  df.tmp$z <- scale(df.tmp$x,center=T)
  #df.tmp <- df.tmp[substr(rownames(df.tmp),1,1) == 'i',]
  df.tmp <- df.tmp[abs(df.tmp$z) >1.5,]
  p[[t.]] <- p.xy(x=pred[[t.]],y=path.t[[t.]],ylab='Actual',xlab='Predicted',
   ttl=paste0(grp,': ',tps[t.],' MPI'),col=col,alpha=0.7) + geom_label_repel(data=df.tmp,aes(x=x,y=y,label=lab),
                     point.padding = 0.5,label.size=0.05,size=1,label.r=0.1,
                     segment.color = 'grey50')
}
  
p <- plot_grid(plotlist=p,align='hv',nrow=1)
ggsave(p,filename = paste(savedir,grp,'CNDRSpaceFit_bidirectionaladditivemodel_label_repel.pdf',sep=''),
       units = 'cm',height = 3.75,width = 3.75*length(tps),useDingbats=FALSE)

# plot fit and separately display hemispheres

p <- lapply(1:length(tps), function(t) 
  p.xyc(x=pred[[t]],y=path.t[[t]],ca=substr(rownames(path.t[[t]]),1,1),ylab='Actual',xlab='Predicted',
        ttl=paste0(grp,': ',tps[t],' MPI'),col=col,alpha=0.7) + 
    theme(legend.position = c(0.1,1),legend.background=element_blank(),legend.key.size = unit(0.1, "cm"),legend.title = element_blank()))
p <- plot_grid(plotlist=p,align='hv',nrow=1)
ggsave(p,filename = paste(savedir,grp,'CNDRSpaceFitHemiColor_bidirectionaladditivemodel.pdf',sep=''),
       units = 'cm',height = 3.75,width = 3.75*length(tps),useDingbats=FALSE)

# initialize empty data frame with all CNDR regions and time points
df.vuln <- df.pred <- data.frame(matrix(ncol=length(tps),nrow=n.regions.CNDR, dimnames=list(path.names, paste(tps,'MPI'))),check.names = FALSE)
for(t in 1:length(tps)){
  regions.mpi <- names(vulnerability[[t]]) # get the regions that had non-zero pathology at each tp (so log can be computed)
  regions.mpi.path.names <- substr(regions.mpi,1,nchar(regions.mpi)-2) # get names of regions without "_1" ("_$MPI") appended
  df.vuln[regions.mpi.path.names,paste(tps[t],'MPI')] <- vulnerability[[t]][regions.mpi]
  df.pred[regions.mpi.path.names,paste(tps[t],'MPI')] <- pred[[t]][regions.mpi]
}

# compute intrinsic vulnerability as an average over time and hemispheres
tp.excl <- '1 MPI' # exclude 1 MPI - see diffmodel/vuln_hemi_time.R
hemi.average.vuln <- hemi.average(df.vuln[,-which(colnames(df.vuln)==tp.excl)])
write.csv(hemi.average.vuln,paste0(savedir,grp,'vulnerability_bidirectional_hemiaverage_exclude',tp.excl,'.csv'))

write.csv(df.vuln,paste0(savedir,grp,'vulnerability_bidirectional.csv')) # save vulnerability for each time point

write.csv(df.pred,paste0(savedir,grp,'log10predictedpath_bidirectional.csv')) # save log10 predicted path

#####################
### Add gene data ###
#####################

# load gene data specified by goi input variable
gene.exp.ABA <- read.csv('data/aba/expression/AllGeneExpression_Fulcher2019.csv',row.names = 1)
df.gene <- hemi.expand.names(gene.exp.ABA)[,goi,drop=F] # make expression hemispherically symmetric and select gene of interest (Mapt)
df.gene.CNDR <- quiet(map.ABA.to.CNDR(df.gene,path.names,ABA.to.CNDR.key)) # convert gene expression data from ABA to CNDR space

##################################################################################
### show how gene expression correlates with hemisphere averaged vulnerability ###
##################################################################################
df.gene.vuln <- merge(hemi.average.vuln,hemi.average(df.gene.CNDR),by=0)
rownames(df.gene.vuln) <- df.gene.vuln$Row.names # delete row name column and make row name attribute
df.gene.vuln <- df.gene.vuln[,-1] 
# look at hemisphere average vulnerability
hemi.average(df.gene.CNDR) # since we duplicated the hemispheres for gene expression this is not changing the data, just unduplicating them and returning to region names without 'i' or 'c'
p <- p.xy(x=df.gene.vuln$v.y,y=df.gene.vuln$v.x,ylab='Vulnerability',xlab=paste0(goi,' Expression'),
          ttl=paste0(grp,': ',tps[t],' MPI'),col=col,alpha=0.7)
ggsave(p,filename = paste(savedir,grp,'CNDRSpaceHemiAverageVulnerability_Exclude',tp.excl,'_bidirectionalmodel_vs',goi,'.pdf',sep=''),
       units = 'cm',height = 3.75,width = 3.75,useDingbats=FALSE)
